---
title: "plotcomp"
author: "me"
date: "2024-07-11"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```
```{r}
if (!require("pacman", quietly = T)) {
    install.packages("pacman")
}
pacman::p_load(tidyverse, cmdstanr, posterior, bayesplot, deSolve, conflicted,
               loo, gridExtra, latex2exp,viridis)

output_folder = "~/Phd material/qAOP_framework/model_comparison"
input_folder = "~/Phd material/qAOP_framework/model_comparison/fits"
source("~/Phd material/qAOP_framework/model_comparison/qAOP_models.R")
conflict_prefer("sd", "stats")
conflict_prefer("filter","dplyr")
```

```{r}

# List all .rds files in the folder
rds_files <- list.files(path = input_folder, pattern = "\\.rds$", full.names = TRUE)

# Read all .rds files into a list
rds_data_list <- lapply(rds_files, readRDS)

# Optionally, you can name the list elements after the files
names(rds_data_list) <- basename(rds_files)

# Print or inspect the list of imported data
print(rds_data_list)

# List all .csv files in the folder
csv_files <- list.files(path = input_folder, pattern = "\\.csv$", full.names = TRUE)

# Read all .csv files into a list
csv_data_list <- lapply(csv_files, read.csv)

# Optionally, you can name the list elements after the files
names(csv_data_list) <- basename(csv_files)

# Print or inspect the list of imported data
print(csv_data_list)

```
#retrieve artificial data in Stan format
```{r}
# Function to process the data
process_data <- function(data) {
  data %>%
    pivot_longer(!c(time, REPLICATE), names_to = "StateVar", values_to = "value") %>%
    group_by(time, StateVar) %>%
    summarise(mean = mean(value), sd = sd(value)) %>%
    ungroup()
}

# Process the data for each model
data_stanA <- process_data(csv_data_list[["fakedata_qAOPA.csv"]]%>%select(-1))
data_stanB <- process_data(csv_data_list[["fakedata_qAOPB.csv"]]%>%select(-1))
data_stanC <- process_data(csv_data_list[["fakedata_qAOPC.csv"]]%>%select(-1))
```


#fit plots
```{r}
# Sequence of time points
finish <- seq(1, 100, by = 0.1)

# Define parameter sets
parsA <- c("tau", "eps", "d1", "k_12", "d2", "k_2", "S0")
parsB <- c("tau", "eps", "d1", "k_12", "d2", "S0")
parsC <- c("tau", "eps", "d1", "k_12", "d2", "k_2", "h_2", "S0")

# List of parameter sets corresponding to each fit object
parameter_sets <- list(
  parsA = parsA,
  parsB = parsB,
  parsC = parsC
)

# List of model functions corresponding to each fit object
model_functions <- list(
  qAOPA = qAOPA,
  qAOPB = qAOPB,
  qAOPC = qAOPC
)

# Function to plot and save results
plot_KE <- function(fit, pars, data, model_func, variable, ymin, ymax, fit_name) {
  draws <- fit$draws(format = "df", variables = pars)
  
  # Extract the relevant data
  data_filtered <- data %>% filter(StateVar == variable)
  
  # Create a dataframe to store all solutions
  all_solutions <- data.frame(time = finish)
  
  # Adjust margins to fit larger labels
  par(mar = c(5, 6, 4, 2) + 0.1)  # Increase left margin for y-axis label
  
  plot(x = data_filtered$time, y = data_filtered$mean, type = "p", pch = 19, ylab = paste0(variable), xlab = "Time", xlim = c(0, 100), ylim = c(ymin, ymax), cex.lab = 3, cex.axis = 2)
  arrows(data_filtered$time, data_filtered$mean - data_filtered$sd, data_filtered$time, data_filtered$mean + data_filtered$sd, length = 0, angle = 90, code = 3, lty = 2, lwd = 0.8)
  
  for (i in 1:100) {
    k <- sample(1:nrow(draws), 1)
    
    pars_values <- as.numeric(draws[k, pars])
    names(pars_values) <- pars
    
    inistate <- c(MIE = as.numeric(draws[k, "S0"]), KE1 = 0, KE2 = 0)
    out <- ode(y = inistate, times = finish, func = model_func, parms = as.list(pars_values))
    
    solution <- data.frame(out) %>% select(time, all_of(variable))
    colnames(solution)[2] <- paste0("solution_", i)
    all_solutions <- left_join(all_solutions, solution, by = "time")
    
    lines(solution, col = alpha("blue", 0.1), lty = 1)
  }
  
  # Calculate the mean solution at each time point
  mean_solution <- all_solutions %>% rowwise() %>% mutate(mean_value = mean(c_across(starts_with("solution_")), na.rm = TRUE))
  lines(mean_solution$time, mean_solution$mean_value, col = "red", lwd = 2)
  
  plot <- recordPlot()
  tiff(paste0(output_folder, "/", variable, "_", fit_name, ".png"), units = "in", width = 9, height = 5.3, res = 700, compression = 'lzw')
  print(plot)
  dev.off()
}

# Define the data sets
data_sets <- list(
  data_stanA = data_stanA,
  data_stanB = data_stanB,
  data_stanC = data_stanC
)

# Loop through each fit object and apply the plot function
for (fit_name in names(rds_data_list)) {
  fit <- rds_data_list[[fit_name]]
  
  # Extract model and data information from the fit name
  model_name <- str_extract(fit_name, "qAOP[ABC]")
  data_name <- str_extract(fit_name, "datafrom[A-C]")
  
  model_func <- model_functions[[model_name]]
  pars <- parameter_sets[[paste0("pars", substr(model_name, 5, 5))]]
  data <- data_sets[[paste0("data_stan", substr(data_name, nchar(data_name), nchar(data_name)))]]
  
  # Adjust ymax for MIE, KE1, and KE2 when using data generated with qAOPC
  if (data_name == "datafromC") {
    plot_KE(fit, pars, data, model_func, "MIE", -0.2, 1.2, fit_name)
    plot_KE(fit, pars, data, model_func, "KE1", -0.2, 1.7, fit_name)
    plot_KE(fit, pars, data, model_func, "KE2", -0.2, 2.5, fit_name)
  } else {
    plot_KE(fit, pars, data, model_func, "MIE", -0.2, 0.7, fit_name)
    plot_KE(fit, pars, data, model_func, "KE1", -0.2, 1.3, fit_name)
    plot_KE(fit, pars, data, model_func, "KE2", -0.2, 1, fit_name)
  }
}

```